diff --git a/Makefile b/Makefile
index 3e55728..52ab7b5 100644
--- a/Makefile
+++ b/Makefile
@@ -96,6 +96,7 @@ models:
 	source sql/config && $(XO) $$DB --int32-type int32 -o $(MODEL_PATH) --template-path $(TEMPLATE_PATH)
 	source sql/config && $(XO) $$DB --int32-type int32 -o $(MODEL_PATH) --query-mode --query-type PotsPaged --query-trim < sql/pots_paged.query.sql
 	source sql/config && $(XO) $$DB --int32-type int32 -o $(MODEL_PATH) --query-mode --query-type CoinsInPot --query-trim < sql/coins_in_pot.query.sql
+	source sql/config && $(XO) $$DB --int32-type int32 -o $(MODEL_PATH) --query-mode --query-type PotById --query-trim < sql/pot_by_id.query.sql
 
 resetdb: clean_db clean_models db
 
diff --git a/design_changes.md b/design_changes.md
new file mode 100644
index 0000000..a198623
--- /dev/null
+++ b/design_changes.md
@@ -0,0 +1,24 @@
+1. schema changes:
+   a. make sure that there is only one recode exists in `coin` table with same `pot_id` and `denomination`
+   which will reduce complex logic required in removing the coins.
+   b. another thing to consider is to remove corresponding records from `pot` table when  `coin` table when
+   a pot is deleted from `pot` table.
+   
+```schema should look like:
+CREATE TABLE IF NOT EXISTS coin (
+id integer NOT NULL PRIMARY KEY AUTOINCREMENT,
+denomination integer NOT NULL,
+coin_count integer NOT NULL,
+pot_id integer NOT NULL,
+FOREIGN KEY (pot_id) REFERENCES pot(id) ON DELETE CASCADE,
+UNIQUE (pot_id, denomination)
+)
+```
+
+2. it will be good if the request payload specifies the
+   kind of coins and number of coins per each kind to remove, which will
+   reduces complexity involved in identifying the random coins to remove.
+
+3.  we can improve the performance by spinning a separate go routine for each coin kind if the request 
+    is modified as mentioned in 2.
+    
\ No newline at end of file
diff --git a/internal/providers/coin/provider.go b/internal/providers/coin/provider.go
index ebe9cf9..2bdb141 100644
--- a/internal/providers/coin/provider.go
+++ b/internal/providers/coin/provider.go
@@ -4,12 +4,15 @@ import (
 	"context"
 	"database/sql"
 	"fmt"
+	"math/rand"
+	"time"
+
 	"github.com/aspiration-labs/pyggpot/internal/models"
 	"github.com/aspiration-labs/pyggpot/rpc/go/coin"
 	"github.com/twitchtv/twirp"
 )
 
-type coinServer struct{
+type coinServer struct {
 	DB *sql.DB
 }
 
@@ -31,9 +34,9 @@ func (s *coinServer) AddCoins(ctx context.Context, request *coin_service.AddCoin
 	for _, coin := range request.Coins {
 		fmt.Println(coin)
 		newCoin := models.Coin{
-			PotID: request.PotId,
+			PotID:        request.PotId,
 			Denomination: int32(coin.Kind),
-			CoinCount: coin.Count,
+			CoinCount:    coin.Count,
 		}
 		err = newCoin.Save(tx)
 		if err != nil {
@@ -50,6 +53,109 @@ func (s *coinServer) AddCoins(ctx context.Context, request *coin_service.AddCoin
 	}, nil
 }
 
-func (s *coinServer) RemoveCoins(context.Context, *coin_service.RemoveCoinsRequest) (*coin_service.CoinsListResponse, error) {
-	panic("implement me")
+func (s *coinServer) RemoveCoins(ctx context.Context, request *coin_service.RemoveCoinsRequest) (*coin_service.CoinsListResponse, error) {
+	if err := request.Validate(); err != nil {
+		return nil, twirp.InvalidArgumentError(err.Error(), "")
+	}
+
+	tx, err := s.DB.Begin()
+	if err != nil {
+		return nil, twirp.InternalError(err.Error())
+	}
+
+	// check pot with pot_id exists, if not return error
+	potId := request.GetPotId()
+	if _, err := models.PotByID(s.DB, potId); err != nil {
+		return nil, twirp.NotFoundError(fmt.Sprintf("pot with id: %v not exist", potId))
+	}
+
+	// if pot with pot_id exists, verify that pot contains requested COINs count to remove
+	coinsInPot, err := models.CoinsInPotsByPot_id(s.DB, int(potId))
+	if err != nil {
+		return nil, twirp.InternalError(err.Error())
+	}
+
+	totalPotCoins := func(coinsInPot []*models.CoinsInPot) int32 {
+		total := int32(0)
+		for _, coinGroup := range coinsInPot {
+			if coinGroup != nil {
+				total += coinGroup.CoinCount
+			}
+		}
+		return total
+	}(coinsInPot)
+
+	numOfCoinsToRemove := request.GetCount()
+	if numOfCoinsToRemove > totalPotCoins {
+		return nil, twirp.InvalidArgumentError(fmt.Sprintf("can not remove: %v coins because pot contains only: %v coins",
+			numOfCoinsToRemove, totalPotCoins), "")
+	}
+
+	// remove the coins with different denominations from the pot
+	toRemove := make(map[int32]int32)
+	rand.Seed(time.Now().UnixNano())
+	for numOfCoinsToRemove > 0 {
+		// get random Coins_Kind and mark it as deleted
+		kinds := CoinKinds()
+		randKind := kinds[rand.Intn(len(kinds))]
+
+		// check if this kind of coins are exists in the pot
+		if found, at := Contains(coinsInPot, randKind); found {
+			if coinsInPot[at].CoinCount > 0 {
+				coinsInPot[at].CoinCount = coinsInPot[at].CoinCount - 1
+				// decrement the total coins to remove by one
+				numOfCoinsToRemove = numOfCoinsToRemove - 1
+				// counts the number of coins deleted of each kind
+				toRemove[randKind] += 1
+			}
+		}
+	}
+
+	// now update the coins table with the remaining coins of each kind
+	for _, coinInPot := range coinsInPot {
+		coin, err := models.CoinByID(s.DB, coinInPot.ID)
+		if err != nil {
+			return nil, err
+		}
+
+		err = coin.Save(tx)
+		if err != nil {
+			return nil, twirp.InvalidArgumentError(err.Error(), "")
+		}
+	}
+
+	err = tx.Commit()
+	if err != nil {
+		return nil, twirp.NotFoundError(err.Error())
+	}
+
+	var removed []*coin_service.Coins
+	for kind, count := range toRemove {
+		// append the removed coins
+		removed = append(removed, &coin_service.Coins{
+			Kind:  coin_service.Coins_Kind(kind),
+			Count: count,
+		})
+	}
+
+	return &coin_service.CoinsListResponse{Coins: removed}, nil
+}
+
+func CoinKinds() []int32 {
+
+	v := make([]int32, 0, len(coin_service.Coins_Kind_name))
+
+	for key, _ := range coin_service.Coins_Kind_name {
+		v = append(v, key)
+	}
+	return v
+}
+
+func Contains(coins []*models.CoinsInPot, k int32) (bool, int) {
+	for pos, c := range coins {
+		if c.Denomination == k {
+			return true, pos
+		}
+	}
+	return false, -1
 }
diff --git a/proto/pot/service.proto b/proto/pot/service.proto
index ce31dfa..e193f32 100644
--- a/proto/pot/service.proto
+++ b/proto/pot/service.proto
@@ -36,7 +36,8 @@ message CreatePotRequest {
     string pot_name = 1 [
         (validator.field) = {
             regex: "^[A-Za-z0-9]{2}(?:[ _-]?[A-Za-z0-9])+$"
-            human_error: "Can contain only alphanumeric characters, dot and underscore."
+//            human_error: "Can contain only alphanumeric characters, dot and underscore."
+            human_error: "Should Start exactly with two alphanumeric characters and a dash or underscore (OR) Can start with at least three alphanumeric characters "
         }
     ]; // required
     int32 max_coins = 2 [(validator.field) = {int_gt:5}];
diff --git a/sql/pot_by_id.query.sql b/sql/pot_by_id.query.sql
new file mode 100644
index 0000000..e2f3874
--- /dev/null
+++ b/sql/pot_by_id.query.sql
@@ -0,0 +1,3 @@
+SELECT id, pot_name, max_coins, create_time
+FROM pot
+WHERE %%id int%%
\ No newline at end of file
